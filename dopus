// Програмування 
//  - процес створення ПЗ.
// Програмування складається з:
//  1. Аналіз задачі
//  2. Проєктування програмного коду
//  3. Написання коду
//  4. Пошук помилок
//  5. Оновлення та підтримка ПЗ
// Парадигма програмування
//  - стиль, підхід та набір прийомів до розробки ПЗ.
// Процедурне програмування
//  - парадигма програмування, яка вимагає виконання алгоритмичної декомпозиції.
// Алгоритмична декомпозиція
//  - розбиття задачі на малі алгоритми, які називаються процедурами або функціями.
// Структурне програмування
//  - різновид процедурного програмування, в якому ми об'єднуємо дані в структури та передаємо структури фукціям на обробку.
// ООП - об'єктно-орієнтоване програмування
//  - підхід (парадигма) до програмування, який будується на об'єктній декомпозиції.
// Об'єктна декомпозиція 
//  - визначення сутностей в програмі, їх характеристики та способи їх взаємодії між собою.
// Мета ООП: 
//  Абстракція - концентрація тільки на найважливішому і відкидання всього не суттєвого.
// Три принципи ООП:
//  1. Інкапсуляція
//      - об'єднання даних і способів їх обробки, при цьому приховуємо внутріншню реалізацію від решти програми та надаємо інтерфейс для
// взаємодії з цією внутрішнею реалізацією.
// Приклад з життя: 
//      Мікрохвильовка
//          - внутрішня реалізація роботи прихована
//          - кнопки, ричажкі і екран це інтерфейс для взаємодії з внутрішньої реалізацією.
// Приклад з C++:
//      Клас string
//          - внутрішня реалізація
//              - динамічний масив символів (char)
//              - виділення та звільнення пам'яті приховано (абстракція)
//          - інтерфейс
//              - набір методів для роботи з рядком (substr, replace тощо)
//              - перевантажені оператори (порівняння, +)
//  2. Спадкування (розширення)
//      - принцип який дозволяє створювати нові класи на основі існуюючих.
//      - принцип взаємодії об'єктів is-a (сутність А є підтипом сутності Б).
// Дві причини використання спадкування:
//  1) Уникнення дублювання коду (DRY принцип)
//      - класи-спадкоємці автоматично отримують всіх членів батьківського класу
//  2) Абстракція в рамках ієрархії
//      - визначення базової реалізації класів і абстракція від конкретної реалізації в клієнтському коді.
// Приклад з життя:
//  - базовий клас Їжа (БЖВ, нутрієнти, мікроелементи)
//      - похідні класи фрукти, овочі, консерви, напівфабрикати тощо
// Прикладний приклад:
//  - клас Character - базовий клас в відеоігрі (хп, ходьба)
//      - Scout, Bomber, Medic, Cannoneer - похідні класи конкретних юнітів, які розширюють базову логіку (власний вид атаки)
// Приклад з С++:
//  - клас exception (метод what, поле message)
//      - bad_cast, logic_error, runtime_error тощо - похідні класи
//  3. Поліморфізм
//      - принцип, який вимагає виконати різну реалізацію однієї задачі для різних даних через один інтерфейс.
//      - один інтерфейс - багато реалізацій.
// Види поліморфізму:
// 1) статичний - визначення конкретної реалізації відбувається на етапі компіляції
//      - перевантаження функцій
//          - створення функцій з однаковим іменем але різним набором параметрів
//      - перевантаження операторів
//          - визначення логіки роботи операторів для користувацьких типів
//      - перевантаження методів
//          - створення методів з однаквим іменем але різним набором параметрів
//      - шаблони функцій
//          - створення основи для автоматичної генерації функції компілятором для потрібних параметрів
//      - шаблони класів
//          - створення основи для автоматичної генерації класів компілятором для потрібних типів полів або параметрів методів.
// 2) динамічний - визначення конкретної реалізації відбувається на етапі виконання
//      - реалізується за допомогою перевизначення віртуальних методів базового класу в класах нащадках.
//      - покажчик (або посилання) на базовий клас і його метод - єдиний інтерфейс
//      - перевизначення методу в класах нащадках - багато реалізацій

ㅤ, [29.10.2025 17:54]
//      - динамічність заключається в тому, що конкретна реалізація визначається на етапі виконання
// Віртуальні функції (або методи)
//  - функція базового класу, яку можна перевизначити в похідному класі.
//  - створюється за допомогою ключового слова virtual
// Чисто віртуальні функції
//  - це віртуальна функція, що не має власної реалізації.
//  - наявність такої фукнції в класі перетворює клас на абстрактний
// Абстрактні класи
//  - це класи, що не можуть мати власних екземплярів (об'єктів)
//  - створюються за допомогою чисто віртуальних функцій
// Інтерфейси
//  - контракт, який зобов'язуються виконати всі класи, що реалізують функціональність цього інтерфейсу
//  - в С++ інтерфейси реалузються як класи, що містять тільки чисто віртуальні функції
// Структури даних
//  - це різні способи зберігання та отримання доступу до даних в програмі.
// Масиви
//  - набір елементів одного типу, які зберігаються послідовно в пам'яті
//  - в C++ реалізується через покажчик на нульовий елемент.
//  - перевага: швидкий доступ до елементу по індексу
//      - формула: (адреса нульового елементу) + (розмір елементу) * (індекс)
//  - недолік: зміна розміру вимагає перевиділення пам'яті та копіювання елементів
// Список (List)
//  - набір елементів (вузлів), що містять значення та покажчик на наступний елемент.
//  - існують двозв'язні списки
//      - кожен елемент містить покажчик на наступний та попередній елемент.
//  - перевага: зміна розміру вимагає лише переназначення покажчиків без копіювання
//  - недолік: доступ до елементу за індексом вимагає перебору всіх елементів до цього індексу
// Черга
//  - структура даних, яка надає доступ до даних за принципом FIFO
//  - FIFO - first in, first out
// Різновиди черги 
//  - кільцева черга - елемент одразу повертається в кінець черги
//  - черга з пріоритетами - елементи з більшим пріоритетом раніше виходять з черги
// Стек
//  - структура даних, яка надає доступ до даних за принципом LIFO
//  - LIFO - last in, first out
//  - приклади: стек виклику функцій, історія дій (Ctrl + Z)
// Композиція
//  - вид взаємодії між об'єктами has-a.
//  - сильне володіння
//  - один об'єкт складається з інших
//  - цикл життя об'єктів міцно пов'язаний
//      - головний об'єкт створюється разом з внутрішніми об'єктами
//      - внутрішні об'єкти знищуються разом з головним об'єктом
// Приклад:
//  - людина і її органи
//      - органи створюються разом з людиною
//      - органи знищуються разом з людиною
// Приклад з C++:
//  - клас string
//      - об'єкт класу string не може існувати без покажчика char*
// Прикладний приклад:
//  - об'єкт гравця (Player)
//      - містить посилання на свої компоненти ігрового об'єкту
// Агрегація
//  - вид взаємодії між об'єктами has-a.
//  - слабке володіння об'єктом
//  - один об'єкт містить в собі інший, але не складається з нього
//  - цикл життя об'єктів не залежить один від одного
//      - головний об'єкт і внутрішній можуть створюватись окремо
//      - головний об'єкт і внутрішній знищуються окремо
// Приклад:
//  - Група - Студенти
// Прикладний приклад:
//  - Клас Group
//  - Клас User
#pragma endregion

ㅤ, [29.10.2025 17:54]
// Компілятор
//  - програма, що компілює код.
// Компіляція
//  - це попередній переклад коду мовою програмування на машинний код.
// Інтерпретатор
//  - програма, що інтерперетує код.
// Інтерпретація
//  - послідовний переклад інструкцій на машинний код і їх виконання.
//  - виконання кожної інструкції відбувається одразу після перекладу
//  - не відбувається попереднього перекладу всієї програми на машинний код.
// Лексеми
//  - найменшою неділимою одиницею мови програмування, яку може розрізнити компілятор
// Лексеми поділяються на:
//  - ключові слова (int, float, if, while тощо)
//  - оператори (+ - / . -> тощо)
//      - операнд - те над чим оператор проводить операцію
//  - літерали (значення, що вказані в коді)
//  - ідентифікатори (імена змінних, функцій, класів, структур тощо)
//      - латинські літери
//      - цифри (але не першим символом)
//      - нижнє підкреслення (_)
//  - розділові знаки ({})
// Змінна
//  - це іменована область пам'яті, що зберігає дані певного типу і може змінювати ці дані
// протягом виконання програми.
// Константа 
//  - це іменована область пам'яті, що зберігає дані певного типу і НЕ може змінювати ці дані 
// протягом виконання програми.ї
// Тип даних
//  - характеристика даних, яка визначає 
//      1) діапазон значень, що можуть зберігатись
//      2) оператори доступні для роботи з цими даними
// Умовні конструкції
//  - конструкція мови програмування яка дозволяє виконувати різні дії в залежності від
// деякої умови. 
//  - if-elseif-else, switch, ?:
// Циклічні конструкції
//  - конструкція мови програмування яка дозволяє виконувати деякі дії певну кількість разів
// в залежності від умови.
//  - while, do-while, for, for(each)
// Функції 
//  - іменований набір інструкцій, який можна викликати та перевикористовувати в програмі.
// Лямбда-функція
//  - це спеціальна анонімна функція, яка не має імені і використовується "на місці".
// Препроцесор
//  - програма, що обробляє код перед компіляцією та виконує директиви.
// Директиви препроцесора
//  - спеціальні команди, які виконує препроцесор.
// Приклад:
//  - define
//  - include
//  - pragma
//      - once
//      - region
// Кодування символів
//  - базовий тип char використовує 1 байт (8 біт) - 2^8 комбінацій 0 та 1 - 256 (0-255)
// 0000.0000
//  - ASCII використовує 7 біт 2^7 - 128 символів (0-127)
//  - розширена таблиця ASCII використовує 8 біт 2^8 - 256 символів
//      - має декілька версій 
//          - windows 1251 - кирилиця
//          - windowd 1252 - центрально та східно єврпоейські латинські символи
//  - Unicode
//      - UTF-8 використовує 1 байт - 256 символів
//      - UTF-16 використовує 2 байти - 16 біт - 2^16 = 65.536 символів
//      - UTF-32 використовує 4 байти - 32 біти - 2^32 = 4.294.967.286 символів
// Покажчики
//  - це спеціальна змінна, що зберігає адресу в оперативній пам'яті.
// Посилання
//  - це друге ім'я (псевдонім) для змінної.
// Способи передачі параметрів у функцію:
//  1) за значенням
//      - фукнція працює з копією
//  2) за адресою
//      - функція працює з копією покажчика, через який має доступ до оригіналу
//  3) за посиланням
//      - функція працює з оригінальною змінною
// Класи, об'єкти
//  - клас — це шаблон (опис) для створення об'єктів.
//  - об'єкт — це конкретний екземпляр класу (створений за шаблоном).
// Приклад:
//  class Car { ... };   
//  Car myCar;           

// Конструктор, деструктор
//  - конструктор — спеціальний метод, який автоматично викликається при створенні об'єкта.
//  - деструктор — спеціальний метод, який викликається при знищенні об'єкта.
// Приклад:
//  class A {
//      A() { }  
//      ~A() { }  
//  };

// Потоки
//  - це механізм введення/виведення даних у C++.
//  - std::cin — введення з клавіатури.
//  - std::cout — виведення на екран.
//  - std::fstream — робота з файлами.

// Покажчик this
//  - спеціальний покажчик, який всередині методу вказує на поточний об'єкт класу.
// Приклад:
//  class A {
//      int x;
//      void setX(int x) { this->x = x; }
//  };

// Перетворення типів в C++
//  - зміна одного типу даних на інший.
//  - static_cast<T>(значення) — безпечне стандартне перетворення.
//  - dynamic_cast<T> — для перетворення між класами з віртуальними методами.
//  - const_cast<T> — додає або прибирає const.
//  - reinterpret_cast<T> — небезпечне перетворення покажчиків (на інший тип).

// Константні методи
//  - методи, які не змінюють дані об'єкта.
//  - позначаються словом const після списку параметрів.
// Приклад:
//  int getX() const { return x; }

// Винятки (class exception)
//  - механізм обробки помилок під час виконання програми.
//  - try — код, який може викликати помилку.
//  - throw — створює виняток.
//  - catch — обробляє виняток.
// Приклад:
//  try { throw std::exception(); }
//  catch (const std::exception& e) { std::cout << e.what(); }

// Перевантаження операторів
//  - можливість визначати власну поведінку операторів (+, -, == тощо) для своїх класів.
// Приклад:
//  class Point {
//      int x, y;
//      Point operator+(const Point& other) { return {x + other.x, y + other.y}; }
//  };

// Семантика копіювання
//  - описує, як об’єкт копіюється (створюється копія).
//  - реалізується через конструктор копіювання та оператор присвоєння.
// Приклад:
//  A(const A& other) { ... }
//  A& operator=(const A& other) { ... return *this; }

// Семантика переміщення
//  - оптимізація копіювання (переміщує ресурси, а не копіює).
//  - використовується для тимчасових об'єктів.
// Приклад:
//  A(A&& other) noexcept { ... }
//  A& operator=(A&& other) noexcept { ... return *this; }

// Розумні покажчики
//  - класи, які автоматично керують динамічною пам'яттю (не треба вручну delete).
//  - std::unique_ptr — єдиний власник.
//  - std::shared_ptr — спільне володіння.
//  - std::weak_ptr — слабке посилання (не впливає на життєвий цикл).

// STL (Standard Template Library)
//  - стандартна бібліотека шаблонів C++.
//  - містить готові контейнери (vector, list, map, set) і алгоритми (sort, find, count).
//  - спрощує роботу з колекціями даних.

// Дружні функції
//  - функції, які мають доступ до приватних членів класу.
//  - оголошуються ключовим словом friend.
// Приклад:
//  class A { friend void show(A a); };

// Статичні члени класу
//  - спільні для всіх об'єктів класу (існують в одному екземплярі).
//  - не належать конкретному об'єкту.
// Приклад:
//  class A { static int count; };

// explicit конструктор
//  - забороняє неявне перетворення типів під час виклику конструктора.
//  - використовується для уникнення помилок.
// Приклад:
//  explicit A(int x) { ... }  // тепер A a = 5; не дозволено

// Системи контролю версій
//  - інструменти для відстеження змін у коді та спільної роботи.
//  - Git — найпопулярніша система.
//  - основні команди: init, add, commit, push, pull, branch, merge.
//  - хостинги: GitHub, GitLab, Bitbucket.

// Шаблони класів
//  - дозволяють створювати класи, що працюють з різними типами даних.
//  - компілятор автоматично створює потрібний варіант.
// Приклад:
//  template<typename T>
//  class Box { T value; };
