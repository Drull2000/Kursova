// Класи, об'єкти
//  - клас — це шаблон (опис) для створення об'єктів.
//  - об'єкт — це конкретний екземпляр класу (створений за шаблоном).
// Приклад:
//  class Car { ... };   
//  Car myCar;           

// Конструктор, деструктор
//  - конструктор — спеціальний метод, який автоматично викликається при створенні об'єкта.
//  - деструктор — спеціальний метод, який викликається при знищенні об'єкта.
// Приклад:
//  class A {
//      A() { }  
//      ~A() { }  
//  };

// Потоки
//  - це механізм введення/виведення даних у C++.
//  - std::cin — введення з клавіатури.
//  - std::cout — виведення на екран.
//  - std::fstream — робота з файлами.

// Покажчик this
//  - спеціальний покажчик, який всередині методу вказує на поточний об'єкт класу.
// Приклад:
//  class A {
//      int x;
//      void setX(int x) { this->x = x; }
//  };

// Перетворення типів в C++
//  - зміна одного типу даних на інший.
//  - static_cast<T>(значення) — безпечне стандартне перетворення.
//  - dynamic_cast<T> — для перетворення між класами з віртуальними методами.
//  - const_cast<T> — додає або прибирає const.
//  - reinterpret_cast<T> — небезпечне перетворення покажчиків (на інший тип).

// Константні методи
//  - методи, які не змінюють дані об'єкта.
//  - позначаються словом const після списку параметрів.
// Приклад:
//  int getX() const { return x; }

// Винятки (class exception)
//  - механізм обробки помилок під час виконання програми.
//  - try — код, який може викликати помилку.
//  - throw — створює виняток.
//  - catch — обробляє виняток.
// Приклад:
//  try { throw std::exception(); }
//  catch (const std::exception& e) { std::cout << e.what(); }

// Перевантаження операторів
//  - можливість визначати власну поведінку операторів (+, -, == тощо) для своїх класів.
// Приклад:
//  class Point {
//      int x, y;
//      Point operator+(const Point& other) { return {x + other.x, y + other.y}; }
//  };

// Семантика копіювання
//  - описує, як об’єкт копіюється (створюється копія).
//  - реалізується через конструктор копіювання та оператор присвоєння.
// Приклад:
//  A(const A& other) { ... }
//  A& operator=(const A& other) { ... return *this; }

// Семантика переміщення
//  - оптимізація копіювання (переміщує ресурси, а не копіює).
//  - використовується для тимчасових об'єктів.
// Приклад:
//  A(A&& other) noexcept { ... }
//  A& operator=(A&& other) noexcept { ... return *this; }

// Розумні покажчики
//  - класи, які автоматично керують динамічною пам'яттю (не треба вручну delete).
//  - std::unique_ptr — єдиний власник.
//  - std::shared_ptr — спільне володіння.
//  - std::weak_ptr — слабке посилання (не впливає на життєвий цикл).

// STL (Standard Template Library)
//  - стандартна бібліотека шаблонів C++.
//  - містить готові контейнери (vector, list, map, set) і алгоритми (sort, find, count).
//  - спрощує роботу з колекціями даних.

// Дружні функції
//  - функції, які мають доступ до приватних членів класу.
//  - оголошуються ключовим словом friend.
// Приклад:
//  class A { friend void show(A a); };

// Статичні члени класу
//  - спільні для всіх об'єктів класу (існують в одному екземплярі).
//  - не належать конкретному об'єкту.
// Приклад:
//  class A { static int count; };

// explicit конструктор
//  - забороняє неявне перетворення типів під час виклику конструктора.
//  - використовується для уникнення помилок.
// Приклад:
//  explicit A(int x) { ... }  // тепер A a = 5; не дозволено

// Системи контролю версій
//  - інструменти для відстеження змін у коді та спільної роботи.
//  - Git — найпопулярніша система.
//  - основні команди: init, add, commit, push, pull, branch, merge.
//  - хостинги: GitHub, GitLab, Bitbucket.

// Шаблони класів
//  - дозволяють створювати класи, що працюють з різними типами даних.
//  - компілятор автоматично створює потрібний варіант.
// Приклад:
//  template<typename T>
//  class Box { T value; };
